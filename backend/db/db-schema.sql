-- ! MAY BE SUBJECT TO UPDATES

CREATE TYPE genders AS ENUM ('Male', 'Female', 'Other', 'Unknown');
CREATE TYPE status AS ENUM ('processing', 'pending', 'completed', 'failed');

create table public.users (
  id bigint generated by default as identity not null,
  username text null,
  name text null,
  type text null,
  gender public.gender null,
  location text null,
  avatar_url text null,
  profile_url text null,
  company text null,
  following bigint null,
  followers bigint null,
  hireable boolean null,
  bio text null,
  public_repos bigint null,
  public_gists bigint null,
  twitter_username text null,
  created_at timestamp with time zone not null default now(),
  last_scraped timestamp with time zone null,
  is_enriched boolean not null default false,
  has_pronouns boolean null,
  private_sponsor_count bigint null,
  email text null,
  github_id bigint null,
  github_created_at timestamp with time zone null,
  min_sponsor_cost numeric null,
  constraint users_pkey primary key (id),
  constraint users_github_id_key unique (github_id),
  constraint users_username_key unique (username)
) TABLESPACE pg_default;

create index IF not exists idx_users_gender on public.users using btree (gender) TABLESPACE pg_default;

create index IF not exists idx_users_type on public.users using btree (type) TABLESPACE pg_default;

create index IF not exists idx_users_username on public.users using btree (username) TABLESPACE pg_default;

create index IF not exists idx_users_name on public.users using btree (name) TABLESPACE pg_default;

create index IF not exists inx_users_location on public.users using btree (location) TABLESPACE pg_default;


create table public.user_activity (
  user_id bigint not null,
  year integer not null,
  last_updated timestamp with time zone null default now(),
  activity_data jsonb null,
  constraint user_activity_pkey primary key (user_id, year),
  constraint user_activity_user_id_fkey foreign KEY (user_id) references users (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create table public.platform (
  id bigint generated by default as identity not null,
  user_id bigint null,
  platform text null,
  constraint platform_pkey primary key (id),
  constraint platform_user_id_fkey foreign KEY (user_id) references users (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create table public.queue (
  id bigint generated by default as identity not null,
  username text null,
  priority bigint null,
  created_at timestamp with time zone not null default now(),
  status public.status null default 'pending'::status,
  github_id bigint null,
  constraint queue_pkey primary key (id),
  constraint queue_github_id_key unique (github_id),
  constraint queue_username_key unique (username),
  constraint queue_github_id_fkey foreign KEY (github_id) references users (github_id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


create table public.sponsorship (
  id bigint generated by default as identity not null,
  sponsor_id bigint null,
  sponsored_id bigint null,
  constraint sponsorship_pkey primary key (id),
  constraint unique_sponsor_sponsored unique (sponsor_id, sponsored_id),
  constraint sponsorship_sponsor_id_fkey foreign KEY (sponsor_id) references users (id) on update CASCADE on delete CASCADE,
  constraint sponsorship_sponsored_id_fkey foreign KEY (sponsored_id) references users (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;


CREATE TABLE public.sponsorship_history (
  id bigint generated by default as identity primary key,
  sponsor_id bigint not null,
  sponsored_id bigint not null,
  started_at timestamp with time zone not null, 
  ended_at timestamp with time zone DEFAULT now(),
  constraint history_sponsor_fkey foreign KEY (sponsor_id) references users (id) on delete CASCADE,
  constraint history_sponsored_fkey foreign KEY (sponsored_id) references users (id) on delete CASCADE
)

CREATE INDEX if not EXISTS idx_sponsorship_history_sponsor ON public.sponsorship_history(sponsor_id);
CREATE INDEX if not EXISTS idx_sponsorship_history_sponsored ON public.sponsorship_history(sponsored_id);
CREATE INDEX if not EXISTS idx_sponsorship_history_dates ON public.sponsorship_history(started_at, ended_at);